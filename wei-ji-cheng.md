出于性能考虑，控制器与模型，不采用继承的方式，避免了多次哈希表合并操作。

控制器，模型类自动伪继承基类 CII\_Controller 、CII\_Model，不需要在控制器或模型脚本中显式继承，继承的工作由 CII 内核完成。PHP脚本位于控制器目录下那它就是一个控制器文件，PHP脚本位于模型目录下那它就是一个模型文件，换句话说就是不再根据继承的基类来区分PHP脚本文件是控制器文件还是模型文件，而是根据文件所在的目录来判断。

> 实际上 CII\_Controller、CII\_Model 基类是不存在的，CII 内核在控制器初始化过程中向控制器、模型注入了一些成员变量与方法，使得看起来控制器、模型像是继承了某个基类。这就是伪继承的含义。

比如，在控制器目录下编写一个类home:

```

```

在访问请求到来时，CII 根据路由读取 Home 类，并向 Home 类中添加 CII 框架所需的成员变量与成员函数，然后实例化 Home 类。上面的 Home 类在被 CII 读取后会变为：

```

```

CII 添加的成员变量会在 Home 构造函数调用前赋值：

```

```

所以，你可以在控制器 Home 中正常使用这成员变量而不用担心它们未定义：

```

```

在定义类时注意不要重载了伪父类的成员属性与方法，如：

```

```

在控制器 Home 中声明一个同名成员变量 lang，CII 会认为你想重载这个变量，就不对它进行实例化为 CII\_Lang 对象的操作了。当然如果你正想重载 lang，这么做是极好的。

伪控制器基类定义：

```

```

伪模型基类定义：

```

```



